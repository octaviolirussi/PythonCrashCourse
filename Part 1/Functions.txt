def greet_user(): --> function definition
    """Display a simple greeting."""
    print("Hello!")

greet_user() --> calling the function

Passing Information to a Function:

For the function to do this, you enter username in the parentheses of the function’s definition 
at def greet_user(). By adding username here you allow the function to accept any value of username you
specify.

def greet_user(username):
    """Display a simple greeting."""
    print(f"Hello, {username.title()}!")
    greet_user('jesse')

Hello, Jesse!

-----------------------------------------------------------------------------------------------------
Arguments and Parameters:

Positional Arguments:

When you call a function, Python must match each argument in the func-
tion call with a parameter in the function definition. The simplest way to
do this is based on the order of the arguments provided. Values matched
up this way are called positional arguments.

def describe_pet(animal_type, pet_name):
    """Display information about a pet."""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet('hamster', 'harry')

You can get unexpected results if you mix up the order of the arguments in
a function call when using positional arguments


Keyword Arguments:

A keyword argument is a name-value pair that you pass to a function. You
directly associate the name and the value within the argument, so when you
pass the argument to the function, there’s no confusion.

describe_pet(animal_type='hamster', pet_name='harry')


Default Values:

When writing a function, you can define a default value for each parameter.
If an argument for a parameter is provided in the function call, Python uses
the argument value. If not, it uses the parameter’s default value.

def describe_pet(pet_name, animal_type='dog'):
    """Display information about a pet."""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet(pet_name='willie')

-------------------------------------------------------------------------------------------------------------------------------
Return Values

A function doesn’t always have to display its output directly. Instead, it can
process some data and then return a value or set of values. The value the
function returns is called a return value. The return statement takes a value
from inside a function and sends it back to the line that called the function.


Returning a Simple Value:

def get_formatted_name(first_name, last_name):
    """Return a full name, neatly formatted."""
    full_name = f"{first_name} {last_name}"
    return full_name.title()

musician = get_formatted_name('jimi', 'hendrix')
print(musician)

-------------------------------------------------------------------------------------------------------------------------------
Passing a List:

When you pass a list to a function, the function gets direct access to the contents of
the list.

def greet_users(names):
    """Print a simple greeting to each user in the list."""
    for name in names:
        msg = f"Hello, {name.title()}!"
        print(msg)

usernames = ['hannah', 'ty', 'margot']
greet_users(usernames)

When you pass a list to a function, the function can modify the list. Any
changes made to the list inside the function’s body are permanent, allowing
you to work efficiently even when you’re dealing with large amounts of data.


Preventing a Function from Modifying a List:

In this case, you can address this issue by passing the function a
copy of the list, not the original. Any changes the function makes to the list
will affect only the copy, leaving the original list intact.

function_name(list_name[:])

---------------------------------------------------------------------------------------------------------------------------------
Passing an Arbitrary Number of Arguments:

Sometimes you won’t know ahead of time how many arguments a function
needs to accept.

def make_pizza(*toppings):
    """Print the list of toppings that have been requested."""
    print(toppings)

make_pizza('pepperoni')
make_pizza('mushrooms', 'green peppers', 'extra cheese')

The asterisk in the parameter name *toppings tells Python to make an
empty tuple called toppings and pack whatever values it receives into this
tuple.


Mixing Positional and Arbitrary Arguments:

If you want a function to accept several different kinds of arguments, the
parameter that accepts an arbitrary number of arguments must be placed
last in the function definition.


def make_pizza(size, *toppings):
    """Summarize the pizza we are about to make."""
    print(f"\nMaking a {size}-inch pizza with the following toppings:")
    for topping in toppings:
        print(f"- {topping}")

make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')


Using Arbitrary Keyword Arguments:

Sometimes you’ll want to accept an arbitrary number of arguments, but you
won’t know ahead of time what kind of information will be passed to the
function. In this case, you can write functions that accept as many key-value
pairs as the calling statement provides.

def build_profile(first, last, **user_info): --> user_info is a dictionary
    """Build a dictionary containing everything we know about a user."""
    user_info['first_name'] = first
    user_info['last_name'] = last
    return user_info

user_profile = build_profile('albert', 'einstein',
location='princeton',
field='physics')

print(user_profile)

{'location': 'princeton', 'field': 'physics',
'first_name': 'albert', 'last_name': 'einstein'}

The definition of build_profile() expects a first and last name, and
then it allows the user to pass in as many name-value pairs as they want. The
double asterisks before the parameter **user_info cause Python to create
an empty dictionary called user_info and pack whatever name-value pairs
it receives into this dictionary. Within the function, you can access the key-
value pairs in user_info just as you would for any dictionary.

In the body of build_profile(), we add the first and last names to the
user_info dictionary because we’ll always receive these two pieces of infor-
mation from the user


