When you create individual objects from the class, each object is automati-
cally equipped with the general behavior; you can then give each object
whatever unique traits you desire.

Creating the Dog Class:

Each instance created from the Dog class will store a name and an age, and
we’ll give each dog the ability to sit() and roll_over():

class Dog:
    """A simple attempt to model a dog."""
    def __init__(self, name, age):
        """Initialize name and age attributes."""
        self.name = name
        self.age = age

    def sit(self):
        """Simulate a dog sitting in response to a command."""
        print(f"{self.name} is now sitting.")

    def roll_over(self):
        """Simulate rolling over in response to a command."""
        print(f"{self.name} rolled over!")

The __init__() method at w is a special method
that Python runs automatically whenever we create a new instance based
on the Dog class.

The self parameter is required in the method definition, and it
must come first before the other parameters. It must be included in the def-
inition because when Python calls this method later (to create an instance
of Dog), the method call will automatically pass the self argument. Every
method call associated with an instance automatically passes self, which is
a reference to the instance itself; it gives the individual instance access to
the attributes and methods in the class.


Making an Instance from a Class:

my_dog = Dog('Willie', 6)
print(f"My dog's name is {my_dog.name}.")
print(f"My dog is {my_dog.age} years old.")


Accessing Attributes and Methods: 

my_dog.name

my_dog.sit()

-------------------------------------------------------------------------------------------------------------------------------------------
One of the first tasks you’ll want to do is modify the attributes
associated with a particular instance. You can modify the attributes of an
instance directly or write methods that update attributes in specific ways.


Setting a Default Value for an Attribute:

When an instance is created, attributes can be defined without being
passed in as parameters. These attributes can be defined in the __init__()
method, where they are assigned a default value.

class Car:
    def __init__(self, make, model, year):
    """Initialize attributes to describe a car."""
    self.make = make
    self.model = model
    self.year = year
    self.odometer_reading = 0

    def read_odometer(self):
        """Print a statement showing the car's mileage."""
        print(f"This car has {self.odometer_reading} miles on it.")


my_new_car.read_odometer()
This car has 0 miles on it.


Modifying an Attribute’s Value Directly:

my_new_car.odometer_reading = 23


Modifying an Attribute’s Value Through a Method:

def update_odometer(self, mileage): 
    """Set the odometer reading to the given value."""
    self.odometer_reading = mileage

my_new_car.update_odometer(23)
my_new_car.read_odometer()

------------------------------------------------------------------------------------------------------------------------------------------
Inheritance:

You don’t always have to start from scratch when writing a class. If the class
you’re writing is a specialized version of another class you wrote, you can
use inheritance. When one class inherits from another, it takes on the attri-
butes and methods of the first class. The original class is called the parent
class, and the new class is the child class.

class ElectricCar(Car): --> At we define the child class, ElectricCar. The name of the parent class must be included in parentheses in the definition of a child class.
    """Represent aspects of a car, specific to electric vehicles."""
    
    def __init__(self, make, model, year): 
        """Initialize attributes of the parent class."""
        super().__init__(make, model, year) --> you must tell which arguments are from the father
        self.battery_size = 75 --> you can add new attributes and methods

my_tesla = ElectricCar('tesla', 'model s', 2019)
print(my_tesla.get_descriptive_name())


The super() function at is a special function that allows you to call
a method from the parent class. This line tells Python to call the __init__()
method from Car, which gives an ElectricCar instance all the attributes
defined in that method. The name super comes from a convention of call-
ing the parent class a superclass and the child class a subclass.


Instances as Attributes:

You’ll find that you have a
growing list of attributes and methods and that your files are becoming
lengthy. In these situations, you might recognize that part of one class can
be written as a separate class.

class Battery:
    """A simple attempt to model a battery for an electric car."""

    def __init__(self, battery_size=75):
        """Initialize the battery's attributes."""
        self.battery_size = battery_size
    
    def describe_battery(self):
        """Print a statement describing the battery size."""
        print(f"This car has a {self.battery_size}-kWh battery.")

class ElectricCar(Car):
    """Represent aspects of a car, specific to electric vehicles."""

    def __init__(self, make, model, year):
        super().__init__(make, model, year)
        self.battery = Battery()


my_tesla.battery.describe_battery()

------------------------------------------------------------------------------------------------------------------------------------
Importing Classes:

As you add more functionality to your classes, your files can get long, even
when you use inheritance properly. In keeping with the overall philosophy
of Python, you’ll want to keep your files as uncluttered as possible. To help,
Python lets you store classes in modules and then import the classes you
need into your main program.

from car import Car

Now we make a separate file called my_car.py. This file will import the
Car class and then create an instance from that class:

from car import Car, ElectricCar

if in the file my_car.py we have the two classes, we can import each separate